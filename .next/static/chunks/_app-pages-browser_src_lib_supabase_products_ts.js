"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_supabase_products_ts"],{

/***/ "(app-pages-browser)/./src/lib/supabase/products.ts":
/*!**************************************!*\
  !*** ./src/lib/supabase/products.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchProductById: () => (/* binding */ fetchProductById),\n/* harmony export */   fetchProducts: () => (/* binding */ fetchProducts)\n/* harmony export */ });\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client */ \"(app-pages-browser)/./src/lib/supabase/client.ts\");\n/* __next_internal_client_entry_do_not_use__ fetchProducts,fetchProductById auto */ \n/**\n * Fetch all products with their current prices\n * @param productType Optional filter by product type (wine/liquor/merchandise)\n * @param onlyAvailable If true, only return products with availability = 'in_stock'\n */ async function fetchProducts(productType) {\n    let onlyAvailable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    // Ensure we're in the browser environment\n    if (false) {}\n    const supabase = (0,_client__WEBPACK_IMPORTED_MODULE_0__.createClient)();\n    try {\n        // First, get products without nested select to avoid issues\n        let query = supabase.from('products').select('*');\n        // Filter by product type if specified\n        if (productType) {\n            query = query.eq('product_type', productType);\n        }\n        // Filter by availability if requested\n        if (onlyAvailable) {\n            query = query.eq('availability', 'in_stock');\n        }\n        // Execute query\n        const { data, error } = await query.order('name');\n        if (error) {\n            console.error('Error fetching products:', error);\n            console.error('Error details:', JSON.stringify(error, null, 2));\n            throw error;\n        }\n        if (!data || data.length === 0) {\n            console.warn('No data returned from products query');\n            return [];\n        }\n        console.log(\"Fetched \".concat(data.length, \" products from database\"));\n        // Now fetch prices separately for products that have them\n        const productIds = data.map((p)=>p.id);\n        const { data: pricesData } = await supabase.from('product_prices').select('*').in('product_id', productIds);\n        // Create a map of product_id -> prices\n        const priceMap = new Map();\n        if (pricesData) {\n            pricesData.forEach((price)=>{\n                if (!priceMap.has(price.product_id)) {\n                    priceMap.set(price.product_id, []);\n                }\n                priceMap.get(price.product_id).push(price);\n            });\n        }\n        // Process the data to get current prices\n        const productsWithPrices = data.map((product)=>{\n            // Get prices for this product\n            const prices = priceMap.get(product.id) || [];\n            const now = new Date();\n            // Find the current valid price (valid_from <= now AND (valid_to IS NULL OR valid_to >= now))\n            const currentPrice = prices.length > 0 ? prices.filter((price)=>{\n                if (!price.valid_from) return false;\n                const validFrom = new Date(price.valid_from);\n                const validTo = price.valid_to ? new Date(price.valid_to) : null;\n                return validFrom <= now && (!validTo || validTo >= now);\n            }).sort((a, b)=>{\n                // Sort by valid_from descending to get the most recent\n                return new Date(b.valid_from).getTime() - new Date(a.valid_from).getTime();\n            })[0] : null;\n            return {\n                id: product.id,\n                name: product.name,\n                description: product.description,\n                product_type: product.product_type,\n                supplier_id: product.supplier_id,\n                image_url: product.image_url,\n                abv: product.abv,\n                volume_ml: product.volume_ml,\n                stock_quantity: product.stock_quantity,\n                availability: product.availability,\n                created_at: product.created_at,\n                price: (currentPrice === null || currentPrice === void 0 ? void 0 : currentPrice.price) || null,\n                currency: (currentPrice === null || currentPrice === void 0 ? void 0 : currentPrice.currency) || 'SEK'\n            };\n        });\n        console.log(\"Processed \".concat(productsWithPrices.length, \" products with prices\"));\n        return productsWithPrices;\n    } catch (error) {\n        console.error('Error in fetchProducts:', error);\n        throw error;\n    }\n}\n/**\n * Fetch a single product by ID with current price\n */ async function fetchProductById(productId) {\n    // Ensure we're in the browser environment\n    if (false) {}\n    const supabase = (0,_client__WEBPACK_IMPORTED_MODULE_0__.createClient)();\n    try {\n        const { data, error } = await supabase.from('products').select(\"\\n        *,\\n        product_prices (\\n          price,\\n          currency,\\n          valid_from,\\n          valid_to\\n        )\\n      \").eq('id', productId).single();\n        if (error) {\n            console.error('Error fetching product:', error);\n            return null;\n        }\n        if (!data) {\n            return null;\n        }\n        const product = data;\n        // Get the most recent valid price\n        const prices = product.product_prices || [];\n        const now = new Date();\n        const currentPrice = prices.filter((price)=>{\n            const validFrom = new Date(price.valid_from);\n            const validTo = price.valid_to ? new Date(price.valid_to) : null;\n            return validFrom <= now && (!validTo || validTo >= now);\n        }).sort((a, b)=>{\n            return new Date(b.valid_from).getTime() - new Date(a.valid_from).getTime();\n        })[0];\n        return {\n            id: product.id,\n            name: product.name,\n            description: product.description,\n            product_type: product.product_type,\n            supplier_id: product.supplier_id,\n            image_url: product.image_url,\n            abv: product.abv,\n            volume_ml: product.volume_ml,\n            stock_quantity: product.stock_quantity,\n            availability: product.availability,\n            created_at: product.created_at,\n            price: (currentPrice === null || currentPrice === void 0 ? void 0 : currentPrice.price) || null,\n            currency: (currentPrice === null || currentPrice === void 0 ? void 0 : currentPrice.currency) || 'SEK'\n        };\n    } catch (error) {\n        console.error('Error in fetchProductById:', error);\n        return null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3VwYWJhc2UvcHJvZHVjdHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O29GQUV3QztBQXlDeEM7Ozs7Q0FJQyxHQUNNLGVBQWVDLGNBQ3BCQyxXQUErQztRQUMvQ0MsZ0JBQUFBLGlFQUF5QjtJQUV6QiwwQ0FBMEM7SUFDMUMsSUFBSSxLQUE2QixFQUFFLEVBR2xDO0lBRUQsTUFBTUcsV0FBV04scURBQVlBO0lBRTdCLElBQUk7UUFDRiw0REFBNEQ7UUFDNUQsSUFBSU8sUUFBUUQsU0FDVEUsSUFBSSxDQUFDLFlBQ0xDLE1BQU0sQ0FBQztRQUVWLHNDQUFzQztRQUN0QyxJQUFJUCxhQUFhO1lBQ2ZLLFFBQVFBLE1BQU1HLEVBQUUsQ0FBQyxnQkFBZ0JSO1FBQ25DO1FBRUEsc0NBQXNDO1FBQ3RDLElBQUlDLGVBQWU7WUFDakJJLFFBQVFBLE1BQU1HLEVBQUUsQ0FBQyxnQkFBZ0I7UUFDbkM7UUFFQSxnQkFBZ0I7UUFDaEIsTUFBTSxFQUFFQyxJQUFJLEVBQUVOLEtBQUssRUFBRSxHQUFHLE1BQU1FLE1BQU1LLEtBQUssQ0FBQztRQUUxQyxJQUFJUCxPQUFPO1lBQ1RELFFBQVFDLEtBQUssQ0FBQyw0QkFBNEJBO1lBQzFDRCxRQUFRQyxLQUFLLENBQUMsa0JBQWtCUSxLQUFLQyxTQUFTLENBQUNULE9BQU8sTUFBTTtZQUM1RCxNQUFNQTtRQUNSO1FBRUEsSUFBSSxDQUFDTSxRQUFRQSxLQUFLSSxNQUFNLEtBQUssR0FBRztZQUM5QlgsUUFBUVksSUFBSSxDQUFDO1lBQ2IsT0FBTyxFQUFFO1FBQ1g7UUFFQVosUUFBUWEsR0FBRyxDQUFDLFdBQXVCLE9BQVpOLEtBQUtJLE1BQU0sRUFBQztRQUVuQywwREFBMEQ7UUFDMUQsTUFBTUcsYUFBYSxLQUFnQkMsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxFQUFFO1FBQ2hELE1BQU0sRUFBRVYsTUFBTVcsVUFBVSxFQUFFLEdBQUcsTUFBTWhCLFNBQ2hDRSxJQUFJ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L3NyYy9saWIvc3VwYWJhc2UvcHJvZHVjdHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICcuL2NsaWVudCc7XG5cbi8vIEV4cG9ydCB0eXBlIHNlcGFyYXRlbHkgdG8gYXZvaWQgU1NSIGlzc3Vlc1xuZXhwb3J0IHR5cGUgUHJvZHVjdFdpdGhQcmljZSA9IHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nIHwgbnVsbDtcbiAgcHJvZHVjdF90eXBlOiAnd2luZScgfCAnbGlxdW9yJyB8ICdtZXJjaGFuZGlzZSc7XG4gIHN1cHBsaWVyX2lkOiBzdHJpbmcgfCBudWxsO1xuICBpbWFnZV91cmw6IHN0cmluZyB8IG51bGw7XG4gIGFidjogbnVtYmVyIHwgbnVsbDtcbiAgdm9sdW1lX21sOiBudW1iZXIgfCBudWxsO1xuICBzdG9ja19xdWFudGl0eTogbnVtYmVyO1xuICBhdmFpbGFiaWxpdHk6ICdpbl9zdG9jaycgfCAnb3V0X29mX3N0b2NrJztcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICBwcmljZTogbnVtYmVyIHwgbnVsbDtcbiAgY3VycmVuY3k6IHN0cmluZztcbn07XG5cbmludGVyZmFjZSBQcm9kdWN0UHJpY2Uge1xuICBwcmljZTogbnVtYmVyO1xuICBjdXJyZW5jeTogc3RyaW5nO1xuICB2YWxpZF9mcm9tOiBzdHJpbmc7XG4gIHZhbGlkX3RvOiBzdHJpbmcgfCBudWxsO1xufVxuXG5pbnRlcmZhY2UgUHJvZHVjdFdpdGhQcmljZXNSYXcge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmcgfCBudWxsO1xuICBwcm9kdWN0X3R5cGU6ICd3aW5lJyB8ICdsaXF1b3InIHwgJ21lcmNoYW5kaXNlJztcbiAgc3VwcGxpZXJfaWQ6IHN0cmluZyB8IG51bGw7XG4gIGltYWdlX3VybDogc3RyaW5nIHwgbnVsbDtcbiAgYWJ2OiBudW1iZXIgfCBudWxsO1xuICB2b2x1bWVfbWw6IG51bWJlciB8IG51bGw7XG4gIHN0b2NrX3F1YW50aXR5OiBudW1iZXI7XG4gIGF2YWlsYWJpbGl0eTogJ2luX3N0b2NrJyB8ICdvdXRfb2Zfc3RvY2snO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIHByb2R1Y3RfcHJpY2VzOiBQcm9kdWN0UHJpY2VbXTtcbn1cblxuLyoqXG4gKiBGZXRjaCBhbGwgcHJvZHVjdHMgd2l0aCB0aGVpciBjdXJyZW50IHByaWNlc1xuICogQHBhcmFtIHByb2R1Y3RUeXBlIE9wdGlvbmFsIGZpbHRlciBieSBwcm9kdWN0IHR5cGUgKHdpbmUvbGlxdW9yL21lcmNoYW5kaXNlKVxuICogQHBhcmFtIG9ubHlBdmFpbGFibGUgSWYgdHJ1ZSwgb25seSByZXR1cm4gcHJvZHVjdHMgd2l0aCBhdmFpbGFiaWxpdHkgPSAnaW5fc3RvY2snXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFByb2R1Y3RzKFxuICBwcm9kdWN0VHlwZT86ICd3aW5lJyB8ICdsaXF1b3InIHwgJ21lcmNoYW5kaXNlJyxcbiAgb25seUF2YWlsYWJsZTogYm9vbGVhbiA9IHRydWVcbik6IFByb21pc2U8UHJvZHVjdFdpdGhQcmljZVtdPiB7XG4gIC8vIEVuc3VyZSB3ZSdyZSBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudFxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKCdmZXRjaFByb2R1Y3RzIGNhbiBvbmx5IGJlIGNhbGxlZCBmcm9tIGNsaWVudCBjb21wb25lbnRzJyk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoKTtcblxuICB0cnkge1xuICAgIC8vIEZpcnN0LCBnZXQgcHJvZHVjdHMgd2l0aG91dCBuZXN0ZWQgc2VsZWN0IHRvIGF2b2lkIGlzc3Vlc1xuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncHJvZHVjdHMnKVxuICAgICAgLnNlbGVjdCgnKicpO1xuXG4gICAgLy8gRmlsdGVyIGJ5IHByb2R1Y3QgdHlwZSBpZiBzcGVjaWZpZWRcbiAgICBpZiAocHJvZHVjdFR5cGUpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ3Byb2R1Y3RfdHlwZScsIHByb2R1Y3RUeXBlKTtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgYnkgYXZhaWxhYmlsaXR5IGlmIHJlcXVlc3RlZFxuICAgIGlmIChvbmx5QXZhaWxhYmxlKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdhdmFpbGFiaWxpdHknLCAnaW5fc3RvY2snKTtcbiAgICB9XG5cbiAgICAvLyBFeGVjdXRlIHF1ZXJ5XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnkub3JkZXIoJ25hbWUnKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvZHVjdHM6JywgZXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIGRhdGEgcmV0dXJuZWQgZnJvbSBwcm9kdWN0cyBxdWVyeScpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBGZXRjaGVkICR7ZGF0YS5sZW5ndGh9IHByb2R1Y3RzIGZyb20gZGF0YWJhc2VgKTtcblxuICAgIC8vIE5vdyBmZXRjaCBwcmljZXMgc2VwYXJhdGVseSBmb3IgcHJvZHVjdHMgdGhhdCBoYXZlIHRoZW1cbiAgICBjb25zdCBwcm9kdWN0SWRzID0gKGRhdGEgYXMgYW55W10pLm1hcChwID0+IHAuaWQpO1xuICAgIGNvbnN0IHsgZGF0YTogcHJpY2VzRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwcm9kdWN0X3ByaWNlcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5pbigncHJvZHVjdF9pZCcsIHByb2R1Y3RJZHMpO1xuXG4gICAgLy8gQ3JlYXRlIGEgbWFwIG9mIHByb2R1Y3RfaWQgLT4gcHJpY2VzXG4gICAgY29uc3QgcHJpY2VNYXAgPSBuZXcgTWFwPHN0cmluZywgYW55W10+KCk7XG4gICAgaWYgKHByaWNlc0RhdGEpIHtcbiAgICAgIChwcmljZXNEYXRhIGFzIGFueVtdKS5mb3JFYWNoKHByaWNlID0+IHtcbiAgICAgICAgaWYgKCFwcmljZU1hcC5oYXMocHJpY2UucHJvZHVjdF9pZCkpIHtcbiAgICAgICAgICBwcmljZU1hcC5zZXQocHJpY2UucHJvZHVjdF9pZCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHByaWNlTWFwLmdldChwcmljZS5wcm9kdWN0X2lkKSEucHVzaChwcmljZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIHRoZSBkYXRhIHRvIGdldCBjdXJyZW50IHByaWNlc1xuICAgIGNvbnN0IHByb2R1Y3RzV2l0aFByaWNlczogUHJvZHVjdFdpdGhQcmljZVtdID0gZGF0YS5tYXAoKHByb2R1Y3Q6IGFueSkgPT4ge1xuICAgICAgLy8gR2V0IHByaWNlcyBmb3IgdGhpcyBwcm9kdWN0XG4gICAgICBjb25zdCBwcmljZXMgPSBwcmljZU1hcC5nZXQocHJvZHVjdC5pZCkgfHwgW107XG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgXG4gICAgICAvLyBGaW5kIHRoZSBjdXJyZW50IHZhbGlkIHByaWNlICh2YWxpZF9mcm9tIDw9IG5vdyBBTkQgKHZhbGlkX3RvIElTIE5VTEwgT1IgdmFsaWRfdG8gPj0gbm93KSlcbiAgICAgIGNvbnN0IGN1cnJlbnRQcmljZSA9IHByaWNlcy5sZW5ndGggPiAwXG4gICAgICAgID8gcHJpY2VzXG4gICAgICAgICAgICAuZmlsdGVyKChwcmljZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgIGlmICghcHJpY2UudmFsaWRfZnJvbSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICBjb25zdCB2YWxpZEZyb20gPSBuZXcgRGF0ZShwcmljZS52YWxpZF9mcm9tKTtcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWRUbyA9IHByaWNlLnZhbGlkX3RvID8gbmV3IERhdGUocHJpY2UudmFsaWRfdG8pIDogbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkRnJvbSA8PSBub3cgJiYgKCF2YWxpZFRvIHx8IHZhbGlkVG8gPj0gbm93KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc29ydCgoYTogYW55LCBiOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgLy8gU29ydCBieSB2YWxpZF9mcm9tIGRlc2NlbmRpbmcgdG8gZ2V0IHRoZSBtb3N0IHJlY2VudFxuICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoYi52YWxpZF9mcm9tKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLnZhbGlkX2Zyb20pLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH0pWzBdXG4gICAgICAgIDogbnVsbDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHByb2R1Y3QuaWQsXG4gICAgICAgIG5hbWU6IHByb2R1Y3QubmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IHByb2R1Y3QuZGVzY3JpcHRpb24sXG4gICAgICAgIHByb2R1Y3RfdHlwZTogcHJvZHVjdC5wcm9kdWN0X3R5cGUsXG4gICAgICAgIHN1cHBsaWVyX2lkOiBwcm9kdWN0LnN1cHBsaWVyX2lkLFxuICAgICAgICBpbWFnZV91cmw6IHByb2R1Y3QuaW1hZ2VfdXJsLFxuICAgICAgICBhYnY6IHByb2R1Y3QuYWJ2LFxuICAgICAgICB2b2x1bWVfbWw6IHByb2R1Y3Qudm9sdW1lX21sLFxuICAgICAgICBzdG9ja19xdWFudGl0eTogcHJvZHVjdC5zdG9ja19xdWFudGl0eSxcbiAgICAgICAgYXZhaWxhYmlsaXR5OiBwcm9kdWN0LmF2YWlsYWJpbGl0eSxcbiAgICAgICAgY3JlYXRlZF9hdDogcHJvZHVjdC5jcmVhdGVkX2F0LFxuICAgICAgICBwcmljZTogY3VycmVudFByaWNlPy5wcmljZSB8fCBudWxsLFxuICAgICAgICBjdXJyZW5jeTogY3VycmVudFByaWNlPy5jdXJyZW5jeSB8fCAnU0VLJyxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2VkICR7cHJvZHVjdHNXaXRoUHJpY2VzLmxlbmd0aH0gcHJvZHVjdHMgd2l0aCBwcmljZXNgKTtcbiAgICByZXR1cm4gcHJvZHVjdHNXaXRoUHJpY2VzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGZldGNoUHJvZHVjdHM6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2ggYSBzaW5nbGUgcHJvZHVjdCBieSBJRCB3aXRoIGN1cnJlbnQgcHJpY2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoUHJvZHVjdEJ5SWQocHJvZHVjdElkOiBzdHJpbmcpOiBQcm9taXNlPFByb2R1Y3RXaXRoUHJpY2UgfCBudWxsPiB7XG4gIC8vIEVuc3VyZSB3ZSdyZSBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudFxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKCdmZXRjaFByb2R1Y3RCeUlkIGNhbiBvbmx5IGJlIGNhbGxlZCBmcm9tIGNsaWVudCBjb21wb25lbnRzJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudCgpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwcm9kdWN0cycpXG4gICAgICAuc2VsZWN0KGBcbiAgICAgICAgKixcbiAgICAgICAgcHJvZHVjdF9wcmljZXMgKFxuICAgICAgICAgIHByaWNlLFxuICAgICAgICAgIGN1cnJlbmN5LFxuICAgICAgICAgIHZhbGlkX2Zyb20sXG4gICAgICAgICAgdmFsaWRfdG9cbiAgICAgICAgKVxuICAgICAgYClcbiAgICAgIC5lcSgnaWQnLCBwcm9kdWN0SWQpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2R1Y3Q6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9kdWN0ID0gZGF0YSBhcyBQcm9kdWN0V2l0aFByaWNlc1JhdztcblxuICAgIC8vIEdldCB0aGUgbW9zdCByZWNlbnQgdmFsaWQgcHJpY2VcbiAgICBjb25zdCBwcmljZXMgPSBwcm9kdWN0LnByb2R1Y3RfcHJpY2VzIHx8IFtdO1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgXG4gICAgY29uc3QgY3VycmVudFByaWNlID0gcHJpY2VzXG4gICAgICAuZmlsdGVyKChwcmljZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZEZyb20gPSBuZXcgRGF0ZShwcmljZS52YWxpZF9mcm9tKTtcbiAgICAgICAgY29uc3QgdmFsaWRUbyA9IHByaWNlLnZhbGlkX3RvID8gbmV3IERhdGUocHJpY2UudmFsaWRfdG8pIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHZhbGlkRnJvbSA8PSBub3cgJiYgKCF2YWxpZFRvIHx8IHZhbGlkVG8gPj0gbm93KTtcbiAgICAgIH0pXG4gICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoYi52YWxpZF9mcm9tKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLnZhbGlkX2Zyb20pLmdldFRpbWUoKTtcbiAgICAgIH0pWzBdO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBwcm9kdWN0LmlkLFxuICAgICAgbmFtZTogcHJvZHVjdC5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IHByb2R1Y3QuZGVzY3JpcHRpb24sXG4gICAgICBwcm9kdWN0X3R5cGU6IHByb2R1Y3QucHJvZHVjdF90eXBlLFxuICAgICAgc3VwcGxpZXJfaWQ6IHByb2R1Y3Quc3VwcGxpZXJfaWQsXG4gICAgICBpbWFnZV91cmw6IHByb2R1Y3QuaW1hZ2VfdXJsLFxuICAgICAgYWJ2OiBwcm9kdWN0LmFidixcbiAgICAgIHZvbHVtZV9tbDogcHJvZHVjdC52b2x1bWVfbWwsXG4gICAgICBzdG9ja19xdWFudGl0eTogcHJvZHVjdC5zdG9ja19xdWFudGl0eSxcbiAgICAgIGF2YWlsYWJpbGl0eTogcHJvZHVjdC5hdmFpbGFiaWxpdHksXG4gICAgICBjcmVhdGVkX2F0OiBwcm9kdWN0LmNyZWF0ZWRfYXQsXG4gICAgICBwcmljZTogY3VycmVudFByaWNlPy5wcmljZSB8fCBudWxsLFxuICAgICAgY3VycmVuY3k6IGN1cnJlbnRQcmljZT8uY3VycmVuY3kgfHwgJ1NFSycsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBmZXRjaFByb2R1Y3RCeUlkOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50IiwiZmV0Y2hQcm9kdWN0cyIsInByb2R1Y3RUeXBlIiwib25seUF2YWlsYWJsZSIsImNvbnNvbGUiLCJlcnJvciIsInN1cGFiYXNlIiwicXVlcnkiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJkYXRhIiwib3JkZXIiLCJKU09OIiwic3RyaW5naWZ5IiwibGVuZ3RoIiwid2FybiIsImxvZyIsInByb2R1Y3RJZHMiLCJtYXAiLCJwIiwiaWQiLCJwcmljZXNEYXRhIiwiaW4iLCJwcmljZU1hcCIsIk1hcCIsImZvckVhY2giLCJwcmljZSIsImhhcyIsInByb2R1Y3RfaWQiLCJzZXQiLCJnZXQiLCJwdXNoIiwicHJvZHVjdHNXaXRoUHJpY2VzIiwicHJvZHVjdCIsInByaWNlcyIsIm5vdyIsIkRhdGUiLCJjdXJyZW50UHJpY2UiLCJmaWx0ZXIiLCJ2YWxpZF9mcm9tIiwidmFsaWRGcm9tIiwidmFsaWRUbyIsInZhbGlkX3RvIiwic29ydCIsImEiLCJiIiwiZ2V0VGltZSIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInByb2R1Y3RfdHlwZSIsInN1cHBsaWVyX2lkIiwiaW1hZ2VfdXJsIiwiYWJ2Iiwidm9sdW1lX21sIiwic3RvY2tfcXVhbnRpdHkiLCJhdmFpbGFiaWxpdHkiLCJjcmVhdGVkX2F0IiwiY3VycmVuY3kiLCJmZXRjaFByb2R1Y3RCeUlkIiwicHJvZHVjdElkIiwic2luZ2xlIiwicHJvZHVjdF9wcmljZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase/products.ts\n"));

/***/ })

}]);